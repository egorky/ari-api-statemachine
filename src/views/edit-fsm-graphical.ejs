<%- include("partials/header", { title: "Edit FSM Graphically: " + fsmId }) %>
<%- include("partials/navigation", { user: user, messages: messages, csrfToken: csrfToken }) %>

<h1>Edit State Machine Graphically: <%= fsmId %></h1>

<div class="editor-container">
    <div class="graph-container">
        <h2>Graph Visualization</h2>
        <div id="graph" style="width: 100%; min-height: 400px; border: 1px solid #ccc;">
            <!-- Graph will be rendered here by d3-graphviz -->
        </div>
        <p>Zoom and pan should be enabled by default.</p>
        <button id="reloadGraphButton">Reload Graph</button>
    </div>

    <div class="forms-container">
        <h2>Graphical Editor</h2>
        <div style="margin-bottom: 10px;">
            <button id="addStateButton">Add State Node</button>
            <button id="setInitialStateButton">Set Selected as Initial</button>
            <span id="selectedNodeActions" style="display:none; margin-left: 20px;">
                <button id="addOnEntryActionButton">Add onEntry Action</button>
                <button id="addOnExitActionButton">Add onExit Action</button>
                <span id="nodeActionIndicator" style="margin-left: 10px; font-style:italic;"></span>
            </span>
            <span id="selectedConnectionActions" style="display:none; margin-left: 20px;">
                <button id="addTransitionActionButton">Add/Edit Actions</button>
                <span id="connectionActionIndicator" style="margin-left: 10px; font-style:italic;"></span>
            </span>
        </div>
        <div id="drawflow-editor" style="width: 100%; height: 600px; border: 1px solid #ccc; margin-bottom: 20px;"></div>
        <button id="saveGraphicalDefinitionButton">Save Graphical Definition</button>

        <div class="form-section" style="margin-top: 20px;">
            <h3>Raw JSON Definition</h3>
            <textarea id="fsmJsonDefinition" rows="10" style="width: 100%; font-family: monospace;" readonly></textarea>
        </div>
    </div>
</div>

<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="/vendor/@hpcc-js/wasm/dist/index.min.js"></script> <!-- Local path -->
<script src="https://unpkg.com/d3-graphviz@3.0.5/build/d3-graphviz.js"></script>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.css">
<script src="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.js"></script>


<script>
document.addEventListener('DOMContentLoaded', function() {
    const fsmId = "<%= fsmId %>";
    const csrfToken = "<%= csrfToken %>";
    const API_TOKEN = <%- JSON.stringify(locals.apiTokenForClient || "") %>;

    let editor;
    let currentFsmDefinition = {};
    let initialFsmStateNodeId = null;
    let loadedFsmTransitions = [];
    let connectionActions = {};
    let currentSelectedNodeId = null;
    let currentSelectedConnectionId = null;
    let defaultNodeCounter = 1;

    function setupEditorAndLoadData() {
        if (API_TOKEN === "SERVER_TOKEN_MISSING") {
            console.error("API_TOKEN is missing on the server. Cannot fetch FSM data.");
            alert("Critical: API Token not configured on the server. FSM editor cannot function. Please configure API_TOKEN in the .env file.");
            // Disable UI elements
            const reloadBtn = document.getElementById("reloadGraphButton");
            if(reloadBtn) reloadBtn.disabled = true;
            const saveBtn = document.getElementById("saveGraphicalDefinitionButton");
            if(saveBtn) saveBtn.disabled = true;
            // Stop further script execution if critical components rely on this.
            // For now, disabling buttons and alerting is the primary action.
            // Consider throwing an error or returning if the rest of the script is in a function.
        }

        const editorContainer = document.getElementById('drawflow-editor');
        editor = new Drawflow(editorContainer); // Assign to the outer scope variable
        editor.reroute = true; // Enable connection rerouting
        editor.start();

        // Example: Add a way to create a new state node
    // This is a simplified way; a proper UI element (button/menu) would be better.
    // editor.addNode('state', 1, 1, 100, 50, 'state-node', { name: 'NewState' }, 'State Node'); // Removed for blank canvas start
    // For testing, let's add it without specific content to see it appear
    // editor.addNode('State Name', 1, 1, 50, 50, 'state-node', { name: 'DefaultState' }, '<h3>State</h3><span>DefaultState</span>');

    // Helper function to create HTML content for a state node
    function createStateNodeHTML(nodeName) {
        return `<div>${nodeName}</div>`;
    }

    // Modify how nodes are added (example, replace the existing addNode line)
    // This is a placeholder for a user-triggered action (e.g., button click)
    let defaultNodeCounter = 1;
    function addStateNodeToEditor(name = `State${defaultNodeCounter++}`, posX = 100, posY = 100) {
        const nodeName = name;
        const htmlContent = createStateNodeHTML(nodeName);
        // inputs: 1, outputs: 1 (generic connection points for now)
        editor.addNode('state', 1, 1, posX, posY, 'state-node', { name: nodeName }, htmlContent);
    }
    // Call it once for an initial example or have a button trigger it.
    // addStateNodeToEditor(); // User will use button

    // --- Event listener for editing node name on double-click ---
    const selectedNodeActionsContainer = document.getElementById('selectedNodeActions');
    const nodeActionIndicator = document.getElementById('nodeActionIndicator');
    const selectedConnectionActionsContainer = document.getElementById('selectedConnectionActions');
    const connectionActionIndicator = document.getElementById('connectionActionIndicator');
    let currentSelectedNodeId = null;
    let currentSelectedConnectionId = null;
    let connectionActions = {}; // Stores actions for connections { connectionId: [actions] }

    editor.on('nodeSelected', function(id) {
        currentSelectedNodeId = id;
        selectedNodeActionsContainer.style.display = 'inline';
        updateActionIndicator(id); // Existing function for node actions

        // Hide connection actions
        selectedConnectionActionsContainer.style.display = 'none';
        connectionActionIndicator.textContent = '';
        currentSelectedConnectionId = null;
        // editor.clearSelectedConnection(); // If drawflow has such a method
    });

    editor.on('nodeUnselected', function(id) { // Assuming 'nodeUnselected' event exists or handling click outside
        // If Drawflow doesn't have 'nodeUnselected', we might need to handle clicks on canvas/editor background
        // For now, let's assume selection clear implies unselected.
        // The action buttons should hide if no node is selected.
        // This might also need to be triggered if a node is deleted.
        if (editor.selected_node == null) { // Check if any node is currently selected
             currentSelectedNodeId = null;
             selectedNodeActionsContainer.style.display = 'none';
             nodeActionIndicator.textContent = '';
        }
    });

    document.getElementById("addTransitionActionButton").addEventListener("click", () => {
        if (currentSelectedConnectionId) {
            // The 'openActionModal' function will need to be adapted for transitions.
            // For now, we can pass a specific type like 'onTransition'.
            openActionModal('onTransition');
        } else {
            displayFlashMessage('error', 'Please select a transition (connection) first.');
        }
    });

    // Fallback for unselecting: click on canvas
    editor.on('click', function(event) {
        if (event.target.classList.contains('parent-drawflow') || event.target.classList.contains('drawflow')) {
            // Clicked on canvas background
            if (currentSelectedNodeId && editor.getNodeFromId(currentSelectedNodeId)) {
                // editor.deselectNode(currentSelectedNodeId); // Drawflow does not have a public deselectNode method
                // For now, simply hide the buttons if the click was on the canvas.
                // A more robust solution would be to manage selection state more explicitly.
            }
            // If a node is not selected after a general click, hide the controls.
            // Drawflow seems to handle its own selection clearing when canvas is clicked.
            // The selected_node property will be null.
             setTimeout(() => { // Allow Drawflow to process its click first
                if (editor.selected_node == null) {
                    currentSelectedNodeId = null;
                    selectedNodeActionsContainer.style.display = 'none';
                    nodeActionIndicator.textContent = '';
                }
                // Also ensure connection actions are hidden if canvas is clicked and no connection selected
                if (editor.selected_connection == null) { // Drawflow might not have selected_connection
                    currentSelectedConnectionId = null;
                    selectedConnectionActionsContainer.style.display = 'none';
                    connectionActionIndicator.textContent = '';
                }
            }, 0);
        }
    });

    editor.on('connectionSelected', function(connectionData) {
        // Drawflow's connectionData usually contains output_id, input_id, output_class, input_class
        // We need a unique ID for the connection. A simple concatenation could work if IDs are stable.
        // For Drawflow, the internal ID might not be directly exposed or suitable as a persistent key.
        // Let's assume connectionData itself can be an object key or we derive a stable ID.
        // A common way to get a unique ID is to use the output and input node IDs and their port names.
        // Example: `conn-${connectionData.output_id}-${connectionData.output_class}-${connectionData.input_id}-${connectionData.input_class}`
        // However, Drawflow's internal connection objects might have an 'id' or we might need to generate one.
        // For now, let's use a placeholder ID generation. The key part is that it's unique for this session.
        // Drawflow does not provide a direct 'id' for connections in the `connectionSelected` event parameter.
        // We'll need to construct one using node IDs and port names for uniqueness.
        const connectionId = `conn-${connectionData.output_id}-${connectionData.output_class}-${connectionData.input_id}-${connectionData.input_class}`;
        currentSelectedConnectionId = connectionId;

        selectedConnectionActionsContainer.style.display = 'inline';
        updateConnectionActionIndicator(connectionId); // To be created

        // Hide node actions & deselect node
        selectedNodeActionsContainer.style.display = 'none';
        nodeActionIndicator.textContent = '';
        currentSelectedNodeId = null;
        if (editor.selected_node) { // If a node was selected
             // editor.deselectNode(editor.selected_node); // No public method, Drawflow usually handles this
             editor.selected_node = null; // Force it if needed, though Drawflow might do this
        }
        console.log("Connection selected:", connectionData, "Assigned ID:", connectionId);
    });

    editor.on('connectionUnselected', function(connectionData) {
        // console.log("Connection unselected:", connectionData); // The parameter might be true/false or the connection object
        // Check if any connection is selected. If not, hide the UI.
        // Drawflow might pass a boolean or the connection object.
        // A more reliable check is if currentSelectedConnectionId is still valid or if editor.selected_connection is null
        // Let's assume for now this event means no connection is selected.
        currentSelectedConnectionId = null;
        selectedConnectionActionsContainer.style.display = 'none';
        connectionActionIndicator.textContent = '';
    });


    editor.on('dblclick', function(event) {
        // Check if the double click was on a node's content
        const target = event.target.closest('.drawflow-node .drawflow_content_node div');
        if (target && target.closest('.drawflow-node')) { // Ensure target and its parent node exist
            const nodeId = target.closest('.drawflow-node').id.substring(5); // e.g., "node-1" -> "1"
            const node = editor.getNodeFromId(nodeId);
            if (!node || !node.data) return; // Node or its data might not exist
            const currentName = node.data.name;

            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.style.width = '100%'; // Ensure it fits
            input.onclick = function(e) { e.stopPropagation(); }; // Prevent Drawflow click
            input.onblur = function() {
                const newName = input.value.trim();
                if (newName && newName !== currentName) {
                    editor.updateNodeDataFromId(nodeId, { name: newName });
                    target.textContent = newName; // Update displayed name
                } else {
                    target.textContent = currentName; // Revert if empty or unchanged
                }
            };
            input.onkeydown = function(e) {
                if (e.key === 'Enter') input.blur();
                if (e.key === 'Escape') {
                    target.textContent = currentName; // Revert
                    input.blur(); // then remove
                }
                e.stopPropagation(); // Prevent Drawflow key events
            };

            target.textContent = ''; // Clear current name
            target.appendChild(input);
            input.focus();
            input.select();
        }
    });

    function displayFlashMessage(type, message) {
        const existingMessages = document.querySelectorAll(".flash-message");
        existingMessages.forEach(msg => msg.remove());
        const nav = document.querySelector("nav");
        const p = document.createElement("p");
        p.className = type + " flash-message";
        p.textContent = message;
        nav.insertAdjacentElement("afterend", p);
        setTimeout(() => p.remove(), 5000);
    }

    async function fetchDotString() {
        const response = await fetch(`/api/fsm/${fsmId}/dot`, {
            headers: { "Authorization": "Bearer " + API_TOKEN }
        });
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `Failed to fetch .dot string: ${response.status}`);
        }
        return await response.text();
    }

    async function fetchFullFsmDefinition() {
        const response = await fetch(`/api/fsm/${fsmId}/definition`, {
            headers: { "Authorization": "Bearer " + API_TOKEN }
        });
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `Failed to fetch FSM definition: ${response.status}`);
        }
        currentFsmDefinition = await response.json();
        document.getElementById("fsmJsonDefinition").value = JSON.stringify(currentFsmDefinition, null, 2);
        // TODO: Initialize Drawflow with this definition
        // initializeDrawflow(currentFsmDefinition);
    }

    async function renderGraph() {
        try {
            const dotString = await fetchDotString();
            d3.select("#graph").graphviz({
                useWorker: false,
                wasmFolder: '/vendor/@hpcc-js/wasm/dist/' // Local path
            })
                .renderDot(dotString)
                .on("end", function () {
                    console.log("Graph rendered for visualization.");
                });
        } catch (error) {
            console.error("Error rendering graph:", error);
            displayFlashMessage("error", "Could not render graph: " + error.message);
            d3.select("#graph").html(`<p style='color:red;'>Error rendering graph: ${error.message}</p>`);
        }
    }

    async function loadInitialData() {
        try {
            editor.clear(); // Clear editor at the start
            initialFsmStateNodeId = null;
            loadedFsmTransitions = []; // Reset this too
            document.querySelectorAll('.drawflow-node.initial-state-node').forEach(n => n.classList.remove('initial-state-node'));

            await fetchFullFsmDefinition(); // Fetches JSON into currentFsmDefinition, populates raw JSON textarea

            // Now load this definition into Drawflow
            if (currentFsmDefinition && Object.keys(currentFsmDefinition).length > 0) {
                loadFsmIntoDrawflow(currentFsmDefinition); // This function will be defined next
            } else {
                console.log("No FSM definition to load into Drawflow, or definition is empty.");
                // Editor is already clear, user starts with a blank canvas.
            }

            await renderGraph(); // Renders d3-graphviz graph from DOT (still useful for comparison)
        } catch (error) {
            console.error("Error loading initial data for Drawflow or d3-graphviz:", error);
            displayFlashMessage("error", "Failed to load FSM data: " + error.message);
            // If Drawflow loading fails, ensure it's cleared or in a usable state
            editor.clear(); // Clear again on error
            initialFsmStateNodeId = null;
            document.querySelectorAll('.drawflow-node.initial-state-node').forEach(n => n.classList.remove('initial-state-node'));
        }
    }

    function loadFsmIntoDrawflow(fsmDefinition) {
       if (!fsmDefinition || !editor) return;
       editor.clear(); // Clear again just in case
       connectionActions = {}; // Clear any existing connection actions
       initialFsmStateNodeId = null; // Reset, as visual markers are also cleared or reapplied

       if (fsmDefinition && fsmDefinition.transitions && Array.isArray(fsmDefinition.transitions)) {
           loadedFsmTransitions = JSON.parse(JSON.stringify(fsmDefinition.transitions)); // Store a deep copy
       } else {
           loadedFsmTransitions = [];
       }

       const stateToNodeIdMap = {};
       let currentX = 50;
       let currentY = 50;
       const xIncrement = 250; // Horizontal spacing
       const yIncrement = 150; // Vertical spacing
       const nodesPerRow = 4;
       let nodesInCurrentRow = 0;

       // Add States (Nodes)
       // Iterate over definition.states if it's an object of objects, or an array
       const states = fsmDefinition.states; // Assuming states is an object { "stateName": { ...details... } }
                                          // Or if it's an array of strings/objects from older defs.

       let stateNames = [];
       if (Array.isArray(states)) { // Handle array of state objects/names
            stateNames = states.map(s => (typeof s === 'string' ? s : s.name)).filter(Boolean);
       } else if (typeof states === 'object' && states !== null) { // Handle object of state objects
            stateNames = Object.keys(states);
       }


       stateNames.forEach(stateName => {
           const nodeHTML = createStateNodeHTML(stateName); // Uses existing helper
           const stateData = { name: stateName }; // Initial data for the node

           // Load onEntry/onExit actions if they exist in the definition
           const fsmStateConfig = fsmDefinition.states[stateName];
           if (fsmStateConfig) {
               if (fsmStateConfig.onEntry) {
                   stateData.onEntryActions = JSON.parse(JSON.stringify(fsmStateConfig.onEntry)); // Deep copy
               }
               if (fsmStateConfig.onExit) {
                   stateData.onExitActions = JSON.parse(JSON.stringify(fsmStateConfig.onExit)); // Deep copy
               }
               // Potentially load other state-specific configurations here in the future
           }

           const nodeId = editor.addNode('state', 1, 1, currentX, currentY, 'state-node', stateData, nodeHTML);
           stateToNodeIdMap[stateName] = nodeId.toString(); // Ensure nodeId is string for map key

           nodesInCurrentRow++;
           if (nodesInCurrentRow >= nodesPerRow) {
               currentX = 50;
               currentY += yIncrement;
               nodesInCurrentRow = 0;
           } else {
               currentX += xIncrement;
           }
       });

       // Set Initial State Indication
       if (fsmDefinition.initial && stateToNodeIdMap[fsmDefinition.initial]) {
           initialFsmStateNodeId = stateToNodeIdMap[fsmDefinition.initial];
           const initialNodeElement = document.querySelector(`#node-${initialFsmStateNodeId}`);
           if (initialNodeElement) {
               initialNodeElement.classList.add('initial-state-node');
           }
           // Ensure the initialFsmStateNodeId is set for the save logic
           console.log(`Initial state "${fsmDefinition.initial}" (Node ID: ${initialFsmStateNodeId}) loaded into Drawflow.`);
       } else if (stateNames.length > 0) { // Only warn if states were actually loaded but initial is missing/mismatched
           console.warn(`FSM definition has an initial state specified ("${fsmDefinition.initial}"), but it was not found among the loaded states, or no initial state defined.`);
       }


       // Add Transitions (Connections)
       if (fsmDefinition.transitions && Array.isArray(fsmDefinition.transitions)) {
           fsmDefinition.transitions.forEach(transition => {
               const fromNodeId = stateToNodeIdMap[transition.from];
               const toNodeId = stateToNodeIdMap[transition.to];

               if (fromNodeId && toNodeId) {
                   // Using default output/input port names ('output_1', 'input_1')
                   // Drawflow automatically assigns unique IDs to connections.
                   // Transition names from the definition are not directly represented on connections yet.
                   editor.addConnection(fromNodeId, toNodeId, 'output_1', 'input_1');

                   // --- NEW LOGIC to load transition actions ---
                   if (transition.actions && Array.isArray(transition.actions) && transition.actions.length > 0) {
                       const outputPortClass = 'output_1'; // Assumption based on addConnection call
                       const inputPortClass = 'input_1';  // Assumption based on addConnection call
                       const connectionId = `conn-${fromNodeId}-${outputPortClass}-${toNodeId}-${inputPortClass}`;

                       connectionActions[connectionId] = JSON.parse(JSON.stringify(transition.actions));
                       console.log(`Loaded ${transition.actions.length} actions for transition from ${transition.from} to ${transition.to} (Connection ID: ${connectionId})`);
                   }
                   // --- END NEW LOGIC ---
               } else {
                   console.warn(`Could not create transition: ${transition.name}. Missing 'from' (${transition.from}) or 'to' (${transition.to}) node in Drawflow map.`);
               }
           });
       }
       console.log("FSM loaded into Drawflow editor.");
    }

    // Placeholder for Drawflow initialization logic
    // function initializeDrawflow(fsmData) {
    //     const editor = new Drawflow(document.getElementById('drawflow-editor'));
    //     editor.start();
    //     // Convert fsmData to Drawflow format and import it
    //     // editor.import({ "drawflow": { ... converted data ... } });
    //     console.log("Drawflow editor initialized (placeholder). FSM Data:", fsmData);
    // }

    document.getElementById("reloadGraphButton").addEventListener("click", async () => {
        displayFlashMessage("success", "Reloading data and graph...");
        await loadInitialData(); // Will also re-fetch FSM definition
    });

    // Initial load
    loadInitialData();

    // --- Action Modal Elements ---
    const actionConfigModal = document.getElementById('actionConfigModal');
    const closeActionModalButton = document.getElementById('closeActionModalButton');
    const saveActionButton = document.getElementById('saveActionButton');
    const cancelActionButton = document.getElementById('cancelActionButton');
    const actionConfigForm = document.getElementById('actionConfigForm');
    const actionModalTitle = document.getElementById('actionModalTitle');
    const currentActionsUl = document.getElementById('currentActionsUl');
    const currentEditingActionIndexInput = document.getElementById('currentEditingActionIndex');
    const currentEditingActionTypeInput = document.getElementById('currentEditingActionType');


    function openActionModal(contextType, existingAction = null, actionIndex = null) {
        currentEditingActionTypeInput.value = contextType; // 'onEntry', 'onExit', or 'onTransition'

        let baseTitle = "Configure Action";
        if (currentSelectedNodeId && (contextType === 'onEntry' || contextType === 'onExit')) {
            const node = editor.getNodeFromId(currentSelectedNodeId);
            const nodeName = node ? node.data.name : currentSelectedNodeId;
            baseTitle = `Configure ${contextType} for Node ${nodeName}`;
        } else if (currentSelectedConnectionId && contextType === 'onTransition') {
            // For transitions, a more descriptive name might be complex to get here (e.g., from-to states)
            // So, using a generic title or the connection ID.
            baseTitle = `Configure Actions for Transition (${currentSelectedConnectionId})`;
        } else {
             baseTitle = `Configure ${contextType} Action`; // Fallback
        }
        actionModalTitle.textContent = baseTitle;

        if (existingAction && typeof existingAction === 'object') {
            actionConfigForm.requestUrl.value = existingAction.request?.url || '';
            actionConfigForm.requestMethod.value = existingAction.request?.method || 'GET';
            actionConfigForm.headers.value = existingAction.request?.headers ? JSON.stringify(existingAction.request.headers, null, 2) : '';
            actionConfigForm.body.value = existingAction.request?.body ? JSON.stringify(existingAction.request.body, null, 2) : '';
            actionConfigForm.storeResponseAs.value = existingAction.storeResponseAs || '';
            actionConfigForm.onSuccess.value = existingAction.onSuccess || '';
            actionConfigForm.onFailure.value = existingAction.onFailure || '';
            currentEditingActionIndexInput.value = actionIndex !== null ? actionIndex.toString() : '';
        } else {
            actionConfigForm.reset(); // Clear form for new action
            currentEditingActionIndexInput.value = ''; // Ensure no index when adding new
        }

        loadActionsIntoModalList(contextType); // Pass contextType
        actionConfigModal.style.display = 'block';
    }

    function closeActionModal() {
        actionConfigModal.style.display = 'none';
        actionConfigForm.reset();
        currentEditingActionIndexInput.value = '';
        currentEditingActionTypeInput.value = '';
    }

    function loadActionsIntoModalList(contextType) {
        let actions = [];
        const actionContextName = currentEditingActionTypeInput.value; // Should be same as contextType

        if (actionContextName === 'onTransition' && currentSelectedConnectionId) {
            actions = connectionActions[currentSelectedConnectionId] || [];
        } else if ((actionContextName === 'onEntry' || actionContextName === 'onExit') && currentSelectedNodeId) {
            const node = editor.getNodeFromId(currentSelectedNodeId);
            if (node && node.data) {
                actions = (actionContextName === 'onEntry' ? node.data.onEntryActions : node.data.onExitActions) || [];
            } else {
                console.error("Selected node not found for loading actions.");
                currentActionsUl.innerHTML = '<li>Error: Selected node not found.</li>';
                return;
            }
        } else {
            console.warn("Cannot load actions: No valid node or connection selected for context:", actionContextName);
            currentActionsUl.innerHTML = '<li>Select a node or transition to see its actions.</li>';
            return;
        }

        currentActionsUl.innerHTML = ''; // Clear list

        if (actions.length === 0) {
            const li = document.createElement('li');
            li.textContent = 'No actions configured yet.';
            currentActionsUl.appendChild(li);
            return;
        }

        actions.forEach((action, index) => {
            const li = document.createElement('li');
            // Display some summary of the action
            let summary = `Action ${index + 1}: ${action.type || 'externalApi'} - ${action.request?.method || 'GET'} ${action.request?.url?.substring(0,30)}...`;
            if(action.storeResponseAs) summary += ` (stores as ${action.storeResponseAs})`;


            const editButton = document.createElement('button');
            editButton.textContent = 'Edit';
            editButton.style.marginLeft = '10px';
            editButton.onclick = () => {
                openActionModal(actionContextName, action, index); // Re-open modal for editing this action
            };

            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';
            deleteButton.style.marginLeft = '5px';
            deleteButton.onclick = () => {
                deleteAction(actionContextName, index); // Pass context for deletion
            };

            li.textContent = summary;
            li.appendChild(editButton);
            li.appendChild(deleteButton);
            currentActionsUl.appendChild(li);
        });
    }

    function deleteAction(contextType, index) {
        const actionContextName = contextType; // Value from currentEditingActionTypeInput

        if (actionContextName === 'onTransition' && currentSelectedConnectionId) {
            let actions = connectionActions[currentSelectedConnectionId] || [];
            if (index >= 0 && index < actions.length) {
                actions.splice(index, 1);
                connectionActions[currentSelectedConnectionId] = actions; // Update the master list
                updateConnectionActionIndicator(currentSelectedConnectionId);
                loadActionsIntoModalList(actionContextName); // Refresh list in modal
            }
        } else if ((actionContextName === 'onEntry' || actionContextName === 'onExit') && currentSelectedNodeId) {
            const node = editor.getNodeFromId(currentSelectedNodeId);
            if (!node || !node.data) {
                console.error("Selected node not found for deleting action.");
                return;
            }
            const actionArrayName = actionContextName === 'onEntry' ? 'onEntryActions' : 'onExitActions';
            let actions = node.data[actionArrayName] || [];

            if (index >= 0 && index < actions.length) {
                actions.splice(index, 1);
                const updateData = { ...node.data, [actionArrayName]: actions };
                editor.updateNodeDataFromId(currentSelectedNodeId, updateData);
                updateActionIndicator(currentSelectedNodeId); // For nodes
                loadActionsIntoModalList(actionContextName); // Refresh list in modal
            }
        } else {
            console.warn("Cannot delete action: No valid node or connection selected for context:", actionContextName);
        }
    }


    closeActionModalButton.onclick = closeActionModal;
    cancelActionButton.onclick = closeActionModal;
    window.onclick = function(event) { // Close modal if clicked outside
        if (event.target == actionConfigModal) {
            closeActionModal();
        }
    }

    saveActionButton.onclick = function() {
        const actionContextName = currentEditingActionTypeInput.value; // 'onEntry', 'onExit', or 'onTransition'
        const editingIndex = currentEditingActionIndexInput.value !== '' ? parseInt(currentEditingActionIndexInput.value) : null;
        let targetObjectForActions; // Will be node.data or connectionActions
        let actionsArrayName; // 'onEntryActions', 'onExitActions', or the connectionId for connectionActions
        let currentId; // Node ID or Connection ID

        if (actionContextName === 'onTransition' && currentSelectedConnectionId) {
            currentId = currentSelectedConnectionId;
            if (!connectionActions[currentId]) {
                connectionActions[currentId] = [];
            }
            // For connections, the 'actions' are directly in connectionActions[currentId]
            // So, actionsArrayName is not used to access a sub-property like in nodes.
            // Instead, we'll operate directly on connectionActions[currentId]
        } else if ((actionContextName === 'onEntry' || actionContextName === 'onExit') && currentSelectedNodeId) {
            currentId = currentSelectedNodeId;
            const node = editor.getNodeFromId(currentId);
            if (!node) {
                displayFlashMessage('error', 'Selected node not found.');
                return;
            }
            targetObjectForActions = node.data; // Actions are stored in node.data
            actionsArrayName = actionContextName === 'onEntry' ? 'onEntryActions' : 'onExitActions';
            if (!targetObjectForActions[actionsArrayName]) {
                targetObjectForActions[actionsArrayName] = [];
            }
        } else {
            displayFlashMessage('error', 'No valid node or transition selected to save action to.');
            return;
        }

        const actionData = {
            type: "externalApi", // Currently only supporting this type
            request: {
                url: actionConfigForm.requestUrl.value.trim(),
                method: actionConfigForm.requestMethod.value,
                headers: {},
                body: null
            },
            storeResponseAs: actionConfigForm.storeResponseAs.value.trim() || undefined,
            onSuccess: actionConfigForm.onSuccess.value.trim() || undefined,
            onFailure: actionConfigForm.onFailure.value.trim() || undefined,
        };

        // Validate URL
        if (!actionData.request.url) {
            displayFlashMessage('error', 'Request URL is required.');
            return;
        }

        // Parse Headers
        try {
            const headersStr = actionConfigForm.headers.value.trim();
            if (headersStr) actionData.request.headers = JSON.parse(headersStr);
        } catch (e) {
            displayFlashMessage('error', 'Invalid JSON in Headers.');
            return;
        }

        // Parse Body
        try {
            const bodyStr = actionConfigForm.body.value.trim();
            if (bodyStr && (actionData.request.method === 'POST' || actionData.request.method === 'PUT' || actionData.request.method === 'PATCH')) {
                 actionData.request.body = JSON.parse(bodyStr);
            } else if (bodyStr) {
                console.warn(`Body content provided for ${actionData.request.method} request, but it might not be used by the server.`);
                // Allow it, server might handle it or user might change method later.
                 actionData.request.body = JSON.parse(bodyStr);
            }
        } catch (e) {
            displayFlashMessage('error', 'Invalid JSON in Body.');
            return;
        }

        // Remove undefined fields for cleaner JSON
        if (!actionData.storeResponseAs) delete actionData.storeResponseAs;
        if (!actionData.onSuccess) delete actionData.onSuccess;
        if (!actionData.onFailure) delete actionData.onFailure;
        if (Object.keys(actionData.request.headers).length === 0) delete actionData.request.headers;
        if (actionData.request.body === null) delete actionData.request.body;


        if (editingIndex !== null && editingIndex >= 0 && editingIndex < (actionContextName === 'onTransition' ? connectionActions[currentId].length : targetObjectForActions[actionsArrayName].length) ) {
            if (actionContextName === 'onTransition') {
                connectionActions[currentId][editingIndex] = actionData;
            } else {
                targetObjectForActions[actionsArrayName][editingIndex] = actionData;
            }
        } else {
            if (actionContextName === 'onTransition') {
                connectionActions[currentId].push(actionData);
            } else {
                targetObjectForActions[actionsArrayName].push(actionData);
            }
        }

        if (actionContextName === 'onTransition') {
            // For connections, data is in connectionActions map, not Drawflow node data
            updateConnectionActionIndicator(currentId);
        } else {
            // For nodes, update Drawflow node data
            const updateData = { ...targetObjectForActions }; // node.data is already targetObjectForActions
            editor.updateNodeDataFromId(currentId, updateData);
            updateActionIndicator(currentId);
        }

        // If staying in modal to add more, just refresh list. Otherwise, close.
        // For now, let's clear the form for a new action and refresh the list.
        actionConfigForm.reset();
        currentEditingActionIndexInput.value = ''; // Ready for new action unless one is explicitly edited from list
        loadActionsIntoModalList(actionContextName); // Refresh list in modal
        // displayFlashMessage('success', `Action saved for ${actionContextName}.`);
        // For a less intrusive experience, don't close modal automatically, let user add more or close.
    };

    function updateActionIndicator(nodeId) {
        if (!nodeId) {
            nodeActionIndicator.textContent = '';
            return;
        }
        const node = editor.getNodeFromId(nodeId);
        if (!node || !node.data) {
            nodeActionIndicator.textContent = '';
            return;
        }
        const onEntryCount = node.data.onEntryActions ? node.data.onEntryActions.length : 0;
        const onExitCount = node.data.onExitActions ? node.data.onExitActions.length : 0;
        let indicatorText = '';
        if (onEntryCount > 0) indicatorText += `onEntry (${onEntryCount}) `;
        if (onExitCount > 0) indicatorText += `onExit (${onExitCount})`;
        nodeActionIndicator.textContent = indicatorText.trim() ? `Actions: ${indicatorText}` : 'No actions';
    }

    function updateConnectionActionIndicator(connectionId) {
        const indicator = document.getElementById('connectionActionIndicator');
        if (!indicator) return;

        if (connectionId && connectionActions[connectionId] && connectionActions[connectionId].length > 0) {
            indicator.textContent = `Actions (${connectionActions[connectionId].length})`;
        } else {
            indicator.textContent = 'No actions';
        }
    }

    document.getElementById("addStateButton").addEventListener("click", () => {
        addStateNodeToEditor(); // Uses the function defined earlier
    });

    document.getElementById("addOnEntryActionButton").addEventListener("click", () => {
        if (currentSelectedNodeId) {
            openActionModal('onEntry');
        } else {
            displayFlashMessage('error', 'Please select a state node first.');
        }
    });

    document.getElementById("addOnExitActionButton").addEventListener("click", () => {
        if (currentSelectedNodeId) {
            openActionModal('onExit');
        } else {
            displayFlashMessage('error', 'Please select a state node first.');
        }
    });

    document.getElementById("setInitialStateButton").addEventListener("click", () => {
       const selectedNodeId = editor.selected_node;
       if (selectedNodeId) {
           if (initialFsmStateNodeId) {
               const oldInitialNodeElement = document.querySelector(`#node-${initialFsmStateNodeId}`);
               if (oldInitialNodeElement) oldInitialNodeElement.classList.remove('initial-state-node');
           }
           initialFsmStateNodeId = selectedNodeId;
           const newInitialNodeElement = document.querySelector(`#node-${initialFsmStateNodeId}`);
           if (newInitialNodeElement) newInitialNodeElement.classList.add('initial-state-node');

           const nodeName = editor.getNodeFromId(selectedNodeId).data.name || `Node ${selectedNodeId}`;
           displayFlashMessage("success", `Node '${nodeName}' set as initial state.`);
       } else {
           displayFlashMessage("error", "No node selected to set as initial state.");
       }
    });

    document.getElementById("saveGraphicalDefinitionButton").addEventListener("click", async () => {
       const drawflowData = editor.export();
       const fsmJson = {
           id: fsmId,
           initial: "",
           states: {}, // Will be populated with names and actions
           transitions: [] // Will be populated based on connections and preserved data
           // externalApis: currentFsmDefinition.externalApis || {} // Preserve existing top-level externalApis definitions
       };
        // Preserve existing top-level definitions if they exist and are not managed by this UI directly
       if (currentFsmDefinition.externalApis) {
           fsmJson.externalApis = currentFsmDefinition.externalApis;
       }
       if (currentFsmDefinition.ariActions) {
            fsmJson.ariActions = currentFsmDefinition.ariActions;
       }


       const nodes = drawflowData.drawflow.Home.data;

       if (initialFsmStateNodeId && nodes[initialFsmStateNodeId] && nodes[initialFsmStateNodeId].data.name) {
           fsmJson.initial = nodes[initialFsmStateNodeId].data.name;
       } else if (Object.keys(nodes).length > 0) {
           displayFlashMessage("error", "Initial state not explicitly set or the initial state node is missing a name. Please select a node, ensure it has a name, and click 'Set Selected as Initial'.");
           return;
       } else if (Object.keys(nodes).length === 0 && loadedFsmTransitions.length === 0) { // Check if editor and loaded transitions are empty
           displayFlashMessage("info", "Nothing to save. Editor is empty and no prior transitions exist.");
           return;
       }


       // Process states, including their actions
       for (const nodeId in nodes) {
           const node = nodes[nodeId];
           const stateName = node.data.name || `State_${nodeId}`; // Ensure consistent naming
           if (!node.data.name) {
               console.warn(`Node ${nodeId} is missing a name. Using generated name: ${stateName}`);
           }

           const stateConfig = {};
           if (node.data.onEntryActions && node.data.onEntryActions.length > 0) {
               stateConfig.onEntry = node.data.onEntryActions;
           }
           if (node.data.onExitActions && node.data.onExitActions.length > 0) {
               stateConfig.onExit = node.data.onExitActions;
           }
           // Add other state-specific properties from node.data if any in future

           fsmJson.states[stateName] = stateConfig;
       }

       // Process transitions with preservation logic (from existing currentFsmDefinition.transitions)
       fsmJson.transitions = []; // Start with an empty array
       const newTransitionsFromGraph = []; // Temporary array for transitions derived from Drawflow

       for (const nodeId in nodes) {
           const node = nodes[nodeId];
           const stateName = node.data.name || `State_${nodeId}`; // Should have name from above pass or dblclick edit

           for (const outputKey in node.outputs) {
               const connections = node.outputs[outputKey].connections;
               connections.forEach(conn => {
                   const targetNodeId = conn.node;
                   const targetNode = nodes[targetNodeId];
                   if (!targetNode || !targetNode.data) {
                       console.warn(`Skipping connection from ${stateName} to non-existent/invalid target node ID ${targetNodeId}`);
                       return;
                   }
                   const targetStateName = targetNode.data.name || `State_${targetNodeId}`;

                   // Try to find this connection in the original loaded transitions
                   let foundOriginalTransition = null;
                   // Create a mutable copy of loadedFsmTransitions for splicing if needed for complex matching,
                   // but for simple findIndex and splice, it's okay on the original if we are careful.
                   // For this logic, we use splice which modifies loadedFsmTransitions.
                   if (loadedFsmTransitions.length > 0) {
                       const originalMatchIndex = loadedFsmTransitions.findIndex(t => t.from === stateName && t.to === targetStateName);
                       if (originalMatchIndex !== -1) {
                           foundOriginalTransition = loadedFsmTransitions.splice(originalMatchIndex, 1)[0]; // Remove to mark as used
                       }
                   }

                   const dfConnectionId = `conn-${nodeId}-${outputKey}-${conn.node}-${conn.input_class}`;
                   let transitionToPush;

                   if (foundOriginalTransition) {
                       transitionToPush = { ...foundOriginalTransition }; // Clone to add dfConnectionId
                   } else {
                       let newTransitionName = `from_${stateName}_to_${targetStateName}`;
                       if (connections.length > 1 || Object.keys(node.outputs).length > 1) {
                           newTransitionName += `_via_${outputKey.replace('output_','')}`;
                       }
                       let nameCounter = 1;
                       let finalNewTransitionName = newTransitionName;
                       while (newTransitionsFromGraph.some(t => t.name === finalNewTransitionName) ||
                              loadedFsmTransitions.some(t => t.name === finalNewTransitionName)) { // check remaining unused originals too
                            finalNewTransitionName = `${newTransitionName}_${nameCounter++}`;
                       }
                       transitionToPush = {
                           name: finalNewTransitionName,
                           from: stateName,
                           to: targetStateName
                           // Add other default properties for new transitions if any
                       };
                   }
                   transitionToPush.dfConnectionId = dfConnectionId; // Store the drawflow connection ID
                   newTransitionsFromGraph.push(transitionToPush);
               });
           }
       }

       // Now, iterate newTransitionsFromGraph to add actions from connectionActions
       newTransitionsFromGraph.forEach(transitionEntry => {
           const dfConnId = transitionEntry.dfConnectionId;
           if (dfConnId && connectionActions[dfConnId] && connectionActions[dfConnId].length > 0) {
               transitionEntry.actions = JSON.parse(JSON.stringify(connectionActions[dfConnId]));
           }
           delete transitionEntry.dfConnectionId; // Clean up temporary property
       });

       fsmJson.transitions = newTransitionsFromGraph;

       // The check for initial state being set if states exist is already done above.
       // if (!fsmJson.initial && Object.keys(fsmJson.states).length > 0) { ... }

       console.log("Converted FSM JSON with transition preservation:", fsmJson);

       try {
           const response = await fetch(`/api/fsm/${fsmId}/save_graphical_definition`, {
               method: "POST",
               headers: {
                   "Content-Type": "application/json",
                   "X-CSRF-Token": csrfToken,
                   "Authorization": "Bearer " + API_TOKEN
               },
               body: JSON.stringify(fsmJson)
           });
           const result = await response.json();
           if (!response.ok) {
               throw new Error(result.error || "Failed to save FSM definition.");
           }
           displayFlashMessage("success", result.message || "FSM saved successfully. Reload graph to see changes.");
           document.getElementById("fsmJsonDefinition").value = JSON.stringify(fsmJson, null, 2);
           await renderGraph();
       } catch (error) {
           console.error("Error saving FSM from graphical editor:", error);
           displayFlashMessage("error", `Save failed: ${error.message}`);
       }
    });

    // Initial load (moved inside setupEditorAndLoadData)
    // loadInitialData(); // This will be called after editor is set up
    } // End of setupEditorAndLoadData

    const checkDrawflowInterval = setInterval(function() {
        if (typeof Drawflow !== 'undefined' && typeof d3 !== 'undefined' && d3.select && d3.select("#graph").graphviz) {
            clearInterval(checkDrawflowInterval);
            console.log('Drawflow and d3-graphviz libraries loaded, proceeding with editor setup.');
            setupEditorAndLoadData();
        } else {
            let missing = [];
            if (typeof Drawflow === 'undefined') missing.push('Drawflow');
            if (typeof d3 === 'undefined') missing.push('D3.js');
            if (typeof d3 !== 'object' || typeof d3.select !== 'function' || !d3.select("#graph").graphviz) missing.push('d3-graphviz');
            console.log('Waiting for libraries to load: ' + missing.join(', ') + '...');
        }
    }, 200); // Check every 200ms

    setTimeout(function() {
        // Check one last time
        if (typeof Drawflow === 'undefined' || typeof d3 === 'undefined' || typeof d3.select !== 'function' || !d3.select("#graph").graphviz) {
            clearInterval(checkDrawflowInterval);
            let missing = [];
            if (typeof Drawflow === 'undefined') missing.push('Drawflow');
            if (typeof d3 === 'undefined') missing.push('D3.js');
            if (typeof d3 !== 'object' || typeof d3.select !== 'function' || !d3.select("#graph").graphviz) missing.push('d3-graphviz');

            console.error('A required library ('+ missing.join(', ') +') failed to load after 10 seconds. Cannot initialize editor.');
            const editorDiv = document.getElementById('drawflow-editor');
            const graphDiv = document.getElementById('graph');
            const message = '<p style="color:red;padding:10px;">Error: Critical graphical editor components (' + missing.join(', ') + ') failed to load. Please check your internet connection or try refreshing the page.</p>';

            if (editorDiv) editorDiv.innerHTML = message;
            if (graphDiv) graphDiv.innerHTML = message;

            // Disable buttons
            const buttonsToDisable = ["saveGraphicalDefinitionButton", "addStateButton", "setInitialStateButton", "reloadGraphButton", "addOnEntryActionButton", "addOnExitActionButton", "addTransitionActionButton"];
            buttonsToDisable.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = true;
            });
        }
    }, 10000); // Timeout after 10 seconds
});
</script>
<style>
    .editor-container { display: flex; gap: 20px; }
    .graph-container {
        flex: 1;
        max-height: 600px; /* Or a suitable fixed height */
        overflow-y: auto;
        /* Potentially add padding or border if needed for visual separation when scrolling */
        border: 1px solid #ddd; /* Add a border for the container */
        padding: 10px; /* Add some padding */
    }
    .forms-container {
        flex: 2;
        /* The Drawflow editor inside has height: 600px.
           The forms-container can simply use flex properties or
           also have a similar height constraint if necessary,
           but flex properties should manage its size relative to graph-container.
           Let's ensure it also has a border and padding for consistency.
        */
        border: 1px solid #ddd;
        padding: 10px;
        /* overflow-y: auto; /* If its content might also exceed 600px */
    }
    .form-section { background-color: #f9f9f9; padding: 15px; margin-bottom: 15px; border-radius: 4px; border: 1px solid #eee; }
    .form-section h3 { margin-top: 0; }
    /* Minimal Drawflow styling if needed, though library usually handles its own */
    #drawflow-editor .drawflow-node { /* Example */ }

    /* Basic Node Styling for Drawflow */
    .drawflow-node.state-node .drawflow_content_node {
        background: #f0f8ff; /* AliceBlue */
        padding: 10px;
        border-radius: 5px;
    }
     .drawflow-node.state-node .drawflow_content_node input { /* Style for input field */
        box-sizing: border-box; /* Ensures padding and border don't increase size */
    }
    .drawflow-node.initial-state-node {
        border: 2px solid #28a745 !important; /* Green border - !important to override default */
        box-shadow: 0 0 10px #28a745;
    }
    /* Add more styling as needed */

    /* Action Modal Styling */
    .modal {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1000; /* Sit on top */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        overflow: auto; /* Enable scroll if needed */
        background-color: rgb(0,0,0); /* Fallback color */
        background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
    }

    .modal-content {
        background-color: #fefefe;
        margin: 10% auto; /* 10% from the top and centered */
        padding: 20px;
        border: 1px solid #888;
        width: 60%; /* Could be more or less, depending on screen size */
        border-radius: 8px;
        box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
    }

    .modal-header {
        padding: 10px 16px;
        background-color: #5cb85c;
        color: white;
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
    }
    .modal-header h2 { margin: 0; }

    .modal-body {padding: 10px 16px;}
    .modal-footer {
        padding: 10px 16px;
        background-color: #f9f9f9;
        text-align: right;
        border-bottom-left-radius: 8px;
        border-bottom-right-radius: 8px;
    }
    .modal-footer button { margin-left: 10px; }

    .close-button {
        color: white;
        float: right;
        font-size: 28px;
        font-weight: bold;
    }
    .close-button:hover,
    .close-button:focus {
        color: #000;
        text-decoration: none;
        cursor: pointer;
    }
    #actionConfigForm label { display: block; margin-top: 10px; }
    #actionConfigForm input[type="text"],
    #actionConfigForm select,
    #actionConfigForm textarea {
        width: 98%;
        padding: 8px;
        margin-top: 5px;
        border: 1px solid #ccc;
        border-radius: 4px;
    }
    #actionConfigForm textarea {
        min-height: 80px;
        font-family: monospace;
    }
</style>

<!-- Action Configuration Modal -->
<div id="actionConfigModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span class="close-button" id="closeActionModalButton">&times;</span>
            <h2 id="actionModalTitle">Configure Action</h2>
        </div>
        <div class="modal-body">
            <form id="actionConfigForm">
                <input type="hidden" id="currentEditingActionIndex" value="">
                <input type="hidden" id="currentEditingActionType" value=""> <!-- e.g., onEntry, onExit -->

                <label for="actionRequestUrl">Request URL:</label>
                <input type="text" id="actionRequestUrl" name="requestUrl" placeholder="e.g., http://api.example.com/data">

                <label for="actionRequestMethod">Request Method:</label>
                <select id="actionRequestMethod" name="requestMethod">
                    <option value="GET">GET</option>
                    <option value="POST">POST</option>
                    <option value="PUT">PUT</option>
                    <option value="DELETE">DELETE</option>
                    <option value="PATCH">PATCH</option>
                </select>

                <label for="actionHeaders">Headers (JSON format):</label>
                <textarea id="actionHeaders" name="headers" placeholder='{ "Content-Type": "application/json" }'></textarea>

                <label for="actionBody">Body (JSON format, for POST/PUT/PATCH):</label>
                <textarea id="actionBody" name="body" placeholder='{ "key": "value" }'></textarea>

                <label for="actionStoreResponseAs">Store Response As (FSM variable name):</label>
                <input type="text" id="actionStoreResponseAs" name="storeResponseAs" placeholder="e.g., userData, apiResult">

                <label for="actionOnSuccess">On Success Transition (optional):</label>
                <input type="text" id="actionOnSuccess" name="onSuccess" placeholder="e.g., next, success">

                <label for="actionOnFailure">On Failure Transition (optional):</label>
                <input type="text" id="actionOnFailure" name="onFailure" placeholder="e.g., error, failed">
            </form>
            <div id="actionsList" style="margin-top: 20px;">
                <h4>Configured Actions for this Hook:</h4>
                <ul id="currentActionsUl"></ul>
            </div>
        </div>
        <div class="modal-footer">
            <button id="saveActionButton">Save Action</button>
            <button id="cancelActionButton">Cancel</button>
        </div>
    </div>
</div>
<%- include("partials/footer") %>
